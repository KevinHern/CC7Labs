Ensayo: 

Título: El manejo de Threads en C es mucho más versátil que en Java

Si pudiera describir la tecnología del presente con una palabra, emplearía el término "Paralelismo". El paralelismo se ha logrado con la evolución de los procesadores, ya que tienen la característica esencial del paralelismo: Multithreading.
Si el procesador es multithreading, esto significa que se puede ejecutar más de un thread a la vez, y con esto se puede lograr una mejora en el procesamiento (en el sentido que se necesita menos tiempo para terminar un proceso). además, nos permite 'delegar' tareas, es decir, se pueden diseñar threads con propósitos específicos.
Sin embargo, caemos a una cuestión... ¿qué lenguaje es el óptimo para el manejo de threads?
Podemos comparar 2 lenguajes populares: Java y C. Java es un lenguaje de alto nivel muy popular que es compatible entre sistemas, mientras C es un lenguaje que nos proporciona más control sobre la computadora y es uno de los lenguajes más rápidos y eficientes. Java es más amigable al usuario, sin embargo, C es mucho más versátil si el programador sabe lo que está haciendo. En términos de Threads, El manejo de Threads en C es mucho más versátil que en Java.

La creación y definición de un thread en C es mas libre y eficiente que en Java. Java es un lenguaje de alto nivel, y los Threads son menos eficientes debido a la abstracción que provee JVM. además, en Java la definición de Threads es parecido más la 'implementación' de uno existente (de aquí sale la famosa interface de Runnable) estamos limitados a la única abstracción que provee JVM. Al contrario, en C, la definición de threads es más libre; C nos provee una Librería para la creación de threads la cual, además de proporcionarnos la herramienta para asignarle la rutina de ejecución, se le puede asignar y modificar otros parámetros como el stack size, el método de scheduling, entre otros. Cabe mencionar que la creación de Threads en Java es costoso, debido a que hay que hacer: asignar e inicializar un gran bloque de memoria que será usado para el stack del thread y se necesita crear, inicializar y añadir descriptores a las estructuras de datos del JVM. Mientras que, en C, al crear un thread solo se le asigna el espacio de memoria para el stack pero no es inicializado. Por eso, C es mucho más versátil en la creación y manejo de threads.

Los métodos de sincronización son más versátiles en C que en Java. Los threads en Java están sujetos a los métodos de sincronización que provee el OS. Es decir, los mecanismos son limitados y pueden ser no eficientes. Entre los mecanismos de sincronización, se puede mencionar los Locks y las Variables de condición. El uso de Locks para la sincronización es más libre en C, ya que al programador se le provee la oportunidad de usar Mutex Locks cuando el desee y puede implementarlos como quiera; se puede tener cuantos locks sea necesario. Eso si, queda a responsabilidad del programador en evitar las situaciones que existan deadlocks. Por otro lado, en java (debido a que es un lenguaje de programación de alto nivel) ya hace ese trabajo por el programador usando la palabra reservada "synchronized". Y con respecto a los Condition variables, la implementación en C no tiene límite; es decir que el programador puede diseñar cuantos cond var considere necesarios; esto implica que se puede tener varios locks asociados a diversos condition variables. Por otro lado, en Java solo se puede tener 1 condition variable. Por tener 1 condition variable, esto no le permite al programador de tener la flexibilidad de usar distintas variables de condición cuando requiera. Otra diferencia clave entre C y java (con respecto a los Locks y Cond vars) es que, en el lenguaje de C, el programador puede definir y modificar ciertos atributos extras mientras en Java no se le provee esta opción de personalización al programador. Por ello, C es una mejor opción en el tema de sincronización que Java.

En conclusión, C presenta mucha mas flexibilidad al programador en el proceso de creación y definición de Threads que Java. Además que los métodos de sincronización que proporciona son más flexibles y versátiles al compararlos también con Java. Y por ello, el manejo de Threads en C es mucho más versátil que en Java.
